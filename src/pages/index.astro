---
import Layout from '../layouts/Layout.astro';
---

<Layout>
	<main class="container">
		<header>
			<h1>🎲 数制编码魔方</h1>
			<p>Number System & Coding Cube - 计算机组成原理可视化学习工具</p>
		</header>

		<div class="tools-grid">
			<!-- 实时多进制转换器 -->
			<section class="converter-section">
				<h2>🔄 实时多进制转换器</h2>
				<div class="input-group">
					<label for="input-number">输入数值:</label>
					<input 
						type="text" 
						id="input-number" 
						placeholder="请输入数值" 
						autocomplete="off"
					>
					<select id="input-base">
						<option value="2">二进制 (Binary)</option>
						<option value="8">八进制 (Octal)</option>
						<option value="10" selected>十进制 (Decimal)</option>
						<option value="16">十六进制 (Hexadecimal)</option>
					</select>
				</div>
				
				<div class="conversion-results">
					<div class="result-item">
						<label>二进制 (Binary):</label>
						<span id="result-binary" class="result-value">-</span>
					</div>
					<div class="result-item">
						<label>八进制 (Octal):</label>
						<span id="result-octal" class="result-value">-</span>
					</div>
					<div class="result-item">
						<label>十进制 (Decimal):</label>
						<span id="result-decimal" class="result-value">-</span>
					</div>
					<div class="result-item">
						<label>十六进制 (Hexadecimal):</label>
						<span id="result-hexadecimal" class="result-value">-</span>
					</div>
				</div>
			</section>

			<!-- 机器码编码解析器 -->
			<section class="encoder-section">
				<h2>🔧 机器码编码解析器</h2>
				<div class="input-group">
					<label for="decimal-input">十进制整数:</label>
					<input 
						type="number" 
						id="decimal-input" 
						placeholder="输入正数或负数" 
						autocomplete="off"
					>
					<select id="bit-width">
						<option value="8">8位</option>
						<option value="16" selected>16位</option>
						<option value="32">32位</option>
					</select>
				</div>

				<div class="encoding-results">
					<div class="encoding-item">
						<h3>原码 (Sign-Magnitude)</h3>
						<div class="binary-display" id="sign-magnitude">-</div>
						<div class="explanation" id="sm-explanation"></div>
					</div>
					<div class="encoding-item">
						<h3>反码 (One's Complement)</h3>
						<div class="binary-display" id="ones-complement">-</div>
						<div class="explanation" id="oc-explanation"></div>
					</div>
					<div class="encoding-item">
						<h3>补码 (Two's Complement)</h3>
						<div class="binary-display" id="twos-complement">-</div>
						<div class="explanation" id="tc-explanation"></div>
					</div>
				</div>
			</section>
		</div>
	</main>
</Layout>

<style>
	.container {
		max-width: 1200px;
		margin: 0 auto;
		padding: 2rem;
		font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
	}

	header {
		text-align: center;
		margin-bottom: 3rem;
	}

	header h1 {
		font-size: 2.5rem;
		color: #2563eb;
		margin-bottom: 0.5rem;
	}

	header p {
		color: #6b7280;
		font-size: 1.1rem;
	}

	.tools-grid {
		display: grid;
		grid-template-columns: 1fr 1fr;
		gap: 2rem;
	}

	@media (max-width: 768px) {
		.tools-grid {
			grid-template-columns: 1fr;
		}
	}

	section {
		background: white;
		border-radius: 12px;
		padding: 2rem;
		box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
		border: 1px solid #e5e7eb;
	}

	section h2 {
		color: #1f2937;
		margin-bottom: 1.5rem;
		font-size: 1.5rem;
	}

	.input-group {
		display: flex;
		flex-direction: column;
		gap: 0.5rem;
		margin-bottom: 2rem;
	}

	.input-group label {
		font-weight: 600;
		color: #374151;
	}

	.input-group input,
	.input-group select {
		padding: 0.75rem;
		border: 2px solid #d1d5db;
		border-radius: 8px;
		font-size: 1rem;
		transition: border-color 0.2s;
	}

	.input-group input:focus,
	.input-group select:focus {
		outline: none;
		border-color: #2563eb;
	}

	.conversion-results,
	.encoding-results {
		display: flex;
		flex-direction: column;
		gap: 1rem;
	}

	.result-item {
		display: flex;
		justify-content: space-between;
		align-items: center;
		padding: 1rem;
		background: #f9fafb;
		border-radius: 8px;
		border-left: 4px solid #2563eb;
	}

	.result-item label {
		font-weight: 600;
		color: #374151;
	}

	.result-value {
		font-family: 'Courier New', monospace;
		font-weight: bold;
		color: #059669;
		background: white;
		padding: 0.5rem;
		border-radius: 4px;
		border: 1px solid #d1d5db;
		min-width: 120px;
		text-align: center;
	}

	.encoding-item {
		background: #f9fafb;
		padding: 1.5rem;
		border-radius: 8px;
		border-left: 4px solid #dc2626;
	}

	.encoding-item h3 {
		margin: 0 0 1rem 0;
		color: #1f2937;
		font-size: 1.1rem;
	}

	.binary-display {
		font-family: 'Courier New', monospace;
		font-size: 1.2rem;
		font-weight: bold;
		color: #dc2626;
		background: white;
		padding: 1rem;
		border-radius: 6px;
		border: 1px solid #d1d5db;
		text-align: center;
		letter-spacing: 2px;
		word-break: break-all;
		margin-bottom: 0.5rem;
	}

	.explanation {
		font-size: 0.9rem;
		color: #6b7280;
		font-style: italic;
	}

	.error {
		color: #dc2626 !important;
		background: #fef2f2 !important;
	}
</style>

<script>
	// 实时多进制转换器
	class NumberBaseConverter {
		constructor() {
			this.inputNumber = document.getElementById('input-number');
			this.inputBase = document.getElementById('input-base');
			this.resultBinary = document.getElementById('result-binary');
			this.resultOctal = document.getElementById('result-octal');
			this.resultDecimal = document.getElementById('result-decimal');
			this.resultHexadecimal = document.getElementById('result-hexadecimal');

			this.bindEvents();
		}

		bindEvents() {
			this.inputNumber.addEventListener('input', () => this.convert());
			this.inputBase.addEventListener('change', () => this.convert());
		}

		convert() {
			const input = this.inputNumber.value.trim();
			const base = parseInt(this.inputBase.value);

			if (!input) {
				this.clearResults();
				return;
			}

			try {
				// 验证输入是否符合选定的进制
				if (!this.isValidForBase(input, base)) {
					throw new Error('输入不符合选定进制');
				}

				// 转换为十进制
				const decimal = parseInt(input, base);
				
				if (isNaN(decimal)) {
					throw new Error('无效输入');
				}

				// 更新各进制结果
				this.resultBinary.textContent = decimal.toString(2);
				this.resultOctal.textContent = decimal.toString(8);
				this.resultDecimal.textContent = decimal.toString(10);
				this.resultHexadecimal.textContent = decimal.toString(16).toUpperCase();

				// 清除错误状态
				this.clearErrorState();

			} catch (error) {
				this.showError();
			}
		}

		isValidForBase(input, base) {
			const validChars = '0123456789ABCDEF'.slice(0, base);
			return input.toUpperCase().split('').every(char => validChars.includes(char));
		}

		clearResults() {
			this.resultBinary.textContent = '-';
			this.resultOctal.textContent = '-';
			this.resultDecimal.textContent = '-';
			this.resultHexadecimal.textContent = '-';
			this.clearErrorState();
		}

		showError() {
			[this.resultBinary, this.resultOctal, this.resultDecimal, this.resultHexadecimal]
				.forEach(el => {
					el.textContent = '错误';
					el.classList.add('error');
				});
		}

		clearErrorState() {
			[this.resultBinary, this.resultOctal, this.resultDecimal, this.resultHexadecimal]
				.forEach(el => el.classList.remove('error'));
		}
	}

	// 机器码编码解析器
	class MachineCodeEncoder {
		constructor() {
			this.decimalInput = document.getElementById('decimal-input');
			this.bitWidth = document.getElementById('bit-width');
			this.signMagnitude = document.getElementById('sign-magnitude');
			this.onesComplement = document.getElementById('ones-complement');
			this.twosComplement = document.getElementById('twos-complement');
			this.smExplanation = document.getElementById('sm-explanation');
			this.ocExplanation = document.getElementById('oc-explanation');
			this.tcExplanation = document.getElementById('tc-explanation');

			this.bindEvents();
		}

		bindEvents() {
			this.decimalInput.addEventListener('input', () => this.encode());
			this.bitWidth.addEventListener('change', () => this.encode());
		}

		encode() {
			const input = this.decimalInput.value.trim();
			const bits = parseInt(this.bitWidth.value);

			if (!input) {
				this.clearResults();
				return;
			}

			try {
				const decimal = parseInt(input);
				
				if (isNaN(decimal)) {
					throw new Error('无效输入');
				}

				// 检查数值范围
				const maxValue = Math.pow(2, bits - 1) - 1;
				const minValue = -Math.pow(2, bits - 1);

				if (decimal > maxValue || decimal < minValue) {
					throw new Error(`超出${bits}位范围: [${minValue}, ${maxValue}]`);
				}

				// 计算各种编码
				const encodings = this.calculateEncodings(decimal, bits);

				// 更新显示
				this.signMagnitude.textContent = encodings.signMagnitude;
				this.onesComplement.textContent = encodings.onesComplement;
				this.twosComplement.textContent = encodings.twosComplement;

				// 更新解释
				this.updateExplanations(decimal, bits, encodings);

				// 清除错误状态
				this.clearErrorState();

			} catch (error) {
				this.showError(error.message);
			}
		}

		calculateEncodings(decimal, bits) {
			const isNegative = decimal < 0;
			const absValue = Math.abs(decimal);

			// 原码
			let signMagnitude = absValue.toString(2).padStart(bits - 1, '0');
			signMagnitude = (isNegative ? '1' : '0') + signMagnitude;

			// 反码
			let onesComplement;
			if (isNegative) {
				// 负数的反码：符号位为1，其余位取反
				onesComplement = '1' + absValue.toString(2).padStart(bits - 1, '0')
					.split('').map(bit => bit === '0' ? '1' : '0').join('');
			} else {
				// 正数的反码等于原码
				onesComplement = signMagnitude;
			}

			// 补码
			let twosComplement;
			if (isNegative) {
				// 负数的补码：反码加1
				let carry = 1;
				twosComplement = onesComplement.split('').reverse().map(bit => {
					if (carry === 0) return bit;
					if (bit === '0') {
						carry = 0;
						return '1';
					} else {
						return '0';
					}
				}).reverse().join('');
			} else {
				// 正数的补码等于原码
				twosComplement = signMagnitude;
			}

			return {
				signMagnitude: this.formatBinary(signMagnitude),
				onesComplement: this.formatBinary(onesComplement),
				twosComplement: this.formatBinary(twosComplement)
			};
		}

		formatBinary(binary) {
			// 每4位添加一个空格，便于阅读
			return binary.replace(/(.{4})/g, '$1 ').trim();
		}

		updateExplanations(decimal, bits, encodings) {
			const isNegative = decimal < 0;
			const absValue = Math.abs(decimal);

			if (isNegative) {
				this.smExplanation.textContent = `负数 ${decimal}：符号位=1，数值部分=${absValue.toString(2)}`;
				this.ocExplanation.textContent = `负数的反码：符号位=1，数值部分各位取反`;
				this.tcExplanation.textContent = `负数的补码：反码 + 1`;
			} else {
				this.smExplanation.textContent = `正数 ${decimal}：符号位=0，数值部分=${absValue.toString(2)}`;
				this.ocExplanation.textContent = `正数的反码等于原码`;
				this.tcExplanation.textContent = `正数的补码等于原码`;
			}
		}

		clearResults() {
			this.signMagnitude.textContent = '-';
			this.onesComplement.textContent = '-';
			this.twosComplement.textContent = '-';
			this.smExplanation.textContent = '';
			this.ocExplanation.textContent = '';
			this.tcExplanation.textContent = '';
			this.clearErrorState();
		}

		showError(message) {
			[this.signMagnitude, this.onesComplement, this.twosComplement]
				.forEach(el => {
					el.textContent = '错误: ' + message;
					el.classList.add('error');
				});
		}

		clearErrorState() {
			[this.signMagnitude, this.onesComplement, this.twosComplement]
				.forEach(el => el.classList.remove('error'));
		}
	}

	// 初始化
	document.addEventListener('DOMContentLoaded', () => {
		new NumberBaseConverter();
		new MachineCodeEncoder();
	});
</script>
