---
import Layout from '../layouts/Layout.astro';
---

<Layout>
	<main class="container">
		<header>
			<h1>ğŸ² æ•°åˆ¶ç¼–ç é­”æ–¹</h1>
			<p>Number System & Coding Cube - è®¡ç®—æœºç»„æˆåŸç†å¯è§†åŒ–å­¦ä¹ å·¥å…·</p>
		</header>

		<div class="tools-grid">
			<!-- å®æ—¶å¤šè¿›åˆ¶è½¬æ¢å™¨ -->
			<section class="converter-section">
				<h2>ğŸ”„ å®æ—¶å¤šè¿›åˆ¶è½¬æ¢å™¨</h2>
				<div class="input-group">
					<label for="input-number">è¾“å…¥æ•°å€¼:</label>
					<input 
						type="text" 
						id="input-number" 
						placeholder="è¯·è¾“å…¥æ•°å€¼" 
						autocomplete="off"
					>
					<select id="input-base">
						<option value="2">äºŒè¿›åˆ¶ (Binary)</option>
						<option value="8">å…«è¿›åˆ¶ (Octal)</option>
						<option value="10" selected>åè¿›åˆ¶ (Decimal)</option>
						<option value="16">åå…­è¿›åˆ¶ (Hexadecimal)</option>
					</select>
				</div>
				
				<div class="conversion-results">
					<div class="result-item">
						<label>äºŒè¿›åˆ¶ (Binary):</label>
						<span id="result-binary" class="result-value">-</span>
					</div>
					<div class="result-item">
						<label>å…«è¿›åˆ¶ (Octal):</label>
						<span id="result-octal" class="result-value">-</span>
					</div>
					<div class="result-item">
						<label>åè¿›åˆ¶ (Decimal):</label>
						<span id="result-decimal" class="result-value">-</span>
					</div>
					<div class="result-item">
						<label>åå…­è¿›åˆ¶ (Hexadecimal):</label>
						<span id="result-hexadecimal" class="result-value">-</span>
					</div>
				</div>
			</section>

			<!-- æœºå™¨ç ç¼–ç è§£æå™¨ -->
			<section class="encoder-section">
				<h2>ğŸ”§ æœºå™¨ç ç¼–ç è§£æå™¨</h2>
				<div class="input-group">
					<label for="decimal-input">åè¿›åˆ¶æ•´æ•°:</label>
					<input 
						type="number" 
						id="decimal-input" 
						placeholder="è¾“å…¥æ­£æ•°æˆ–è´Ÿæ•°" 
						autocomplete="off"
					>
					<select id="bit-width">
						<option value="8">8ä½</option>
						<option value="16" selected>16ä½</option>
						<option value="32">32ä½</option>
					</select>
				</div>

				<div class="encoding-results">
					<div class="encoding-item">
						<h3>åŸç  (Sign-Magnitude)</h3>
						<div class="binary-display" id="sign-magnitude">-</div>
						<div class="explanation" id="sm-explanation"></div>
					</div>
					<div class="encoding-item">
						<h3>åç  (One's Complement)</h3>
						<div class="binary-display" id="ones-complement">-</div>
						<div class="explanation" id="oc-explanation"></div>
					</div>
					<div class="encoding-item">
						<h3>è¡¥ç  (Two's Complement)</h3>
						<div class="binary-display" id="twos-complement">-</div>
						<div class="explanation" id="tc-explanation"></div>
					</div>
				</div>
			</section>
		</div>
	</main>
</Layout>

<style>
	.container {
		max-width: 1200px;
		margin: 0 auto;
		padding: 2rem;
		font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
	}

	header {
		text-align: center;
		margin-bottom: 3rem;
	}

	header h1 {
		font-size: 2.5rem;
		color: #2563eb;
		margin-bottom: 0.5rem;
	}

	header p {
		color: #6b7280;
		font-size: 1.1rem;
	}

	.tools-grid {
		display: grid;
		grid-template-columns: 1fr 1fr;
		gap: 2rem;
	}

	@media (max-width: 768px) {
		.tools-grid {
			grid-template-columns: 1fr;
		}
	}

	section {
		background: white;
		border-radius: 12px;
		padding: 2rem;
		box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
		border: 1px solid #e5e7eb;
	}

	section h2 {
		color: #1f2937;
		margin-bottom: 1.5rem;
		font-size: 1.5rem;
	}

	.input-group {
		display: flex;
		flex-direction: column;
		gap: 0.5rem;
		margin-bottom: 2rem;
	}

	.input-group label {
		font-weight: 600;
		color: #374151;
	}

	.input-group input,
	.input-group select {
		padding: 0.75rem;
		border: 2px solid #d1d5db;
		border-radius: 8px;
		font-size: 1rem;
		transition: border-color 0.2s;
	}

	.input-group input:focus,
	.input-group select:focus {
		outline: none;
		border-color: #2563eb;
	}

	.conversion-results,
	.encoding-results {
		display: flex;
		flex-direction: column;
		gap: 1rem;
	}

	.result-item {
		display: flex;
		justify-content: space-between;
		align-items: center;
		padding: 1rem;
		background: #f9fafb;
		border-radius: 8px;
		border-left: 4px solid #2563eb;
	}

	.result-item label {
		font-weight: 600;
		color: #374151;
	}

	.result-value {
		font-family: 'Courier New', monospace;
		font-weight: bold;
		color: #059669;
		background: white;
		padding: 0.5rem;
		border-radius: 4px;
		border: 1px solid #d1d5db;
		min-width: 120px;
		text-align: center;
	}

	.encoding-item {
		background: #f9fafb;
		padding: 1.5rem;
		border-radius: 8px;
		border-left: 4px solid #dc2626;
	}

	.encoding-item h3 {
		margin: 0 0 1rem 0;
		color: #1f2937;
		font-size: 1.1rem;
	}

	.binary-display {
		font-family: 'Courier New', monospace;
		font-size: 1.2rem;
		font-weight: bold;
		color: #dc2626;
		background: white;
		padding: 1rem;
		border-radius: 6px;
		border: 1px solid #d1d5db;
		text-align: center;
		letter-spacing: 2px;
		word-break: break-all;
		margin-bottom: 0.5rem;
	}

	.explanation {
		font-size: 0.9rem;
		color: #6b7280;
		font-style: italic;
	}

	.error {
		color: #dc2626 !important;
		background: #fef2f2 !important;
	}
</style>

<script>
	// å®æ—¶å¤šè¿›åˆ¶è½¬æ¢å™¨
	class NumberBaseConverter {
		constructor() {
			this.inputNumber = document.getElementById('input-number');
			this.inputBase = document.getElementById('input-base');
			this.resultBinary = document.getElementById('result-binary');
			this.resultOctal = document.getElementById('result-octal');
			this.resultDecimal = document.getElementById('result-decimal');
			this.resultHexadecimal = document.getElementById('result-hexadecimal');

			this.bindEvents();
		}

		bindEvents() {
			this.inputNumber.addEventListener('input', () => this.convert());
			this.inputBase.addEventListener('change', () => this.convert());
		}

		convert() {
			const input = this.inputNumber.value.trim();
			const base = parseInt(this.inputBase.value);

			if (!input) {
				this.clearResults();
				return;
			}

			try {
				// éªŒè¯è¾“å…¥æ˜¯å¦ç¬¦åˆé€‰å®šçš„è¿›åˆ¶
				if (!this.isValidForBase(input, base)) {
					throw new Error('è¾“å…¥ä¸ç¬¦åˆé€‰å®šè¿›åˆ¶');
				}

				// è½¬æ¢ä¸ºåè¿›åˆ¶
				const decimal = parseInt(input, base);
				
				if (isNaN(decimal)) {
					throw new Error('æ— æ•ˆè¾“å…¥');
				}

				// æ›´æ–°å„è¿›åˆ¶ç»“æœ
				this.resultBinary.textContent = decimal.toString(2);
				this.resultOctal.textContent = decimal.toString(8);
				this.resultDecimal.textContent = decimal.toString(10);
				this.resultHexadecimal.textContent = decimal.toString(16).toUpperCase();

				// æ¸…é™¤é”™è¯¯çŠ¶æ€
				this.clearErrorState();

			} catch (error) {
				this.showError();
			}
		}

		isValidForBase(input, base) {
			const validChars = '0123456789ABCDEF'.slice(0, base);
			return input.toUpperCase().split('').every(char => validChars.includes(char));
		}

		clearResults() {
			this.resultBinary.textContent = '-';
			this.resultOctal.textContent = '-';
			this.resultDecimal.textContent = '-';
			this.resultHexadecimal.textContent = '-';
			this.clearErrorState();
		}

		showError() {
			[this.resultBinary, this.resultOctal, this.resultDecimal, this.resultHexadecimal]
				.forEach(el => {
					el.textContent = 'é”™è¯¯';
					el.classList.add('error');
				});
		}

		clearErrorState() {
			[this.resultBinary, this.resultOctal, this.resultDecimal, this.resultHexadecimal]
				.forEach(el => el.classList.remove('error'));
		}
	}

	// æœºå™¨ç ç¼–ç è§£æå™¨
	class MachineCodeEncoder {
		constructor() {
			this.decimalInput = document.getElementById('decimal-input');
			this.bitWidth = document.getElementById('bit-width');
			this.signMagnitude = document.getElementById('sign-magnitude');
			this.onesComplement = document.getElementById('ones-complement');
			this.twosComplement = document.getElementById('twos-complement');
			this.smExplanation = document.getElementById('sm-explanation');
			this.ocExplanation = document.getElementById('oc-explanation');
			this.tcExplanation = document.getElementById('tc-explanation');

			this.bindEvents();
		}

		bindEvents() {
			this.decimalInput.addEventListener('input', () => this.encode());
			this.bitWidth.addEventListener('change', () => this.encode());
		}

		encode() {
			const input = this.decimalInput.value.trim();
			const bits = parseInt(this.bitWidth.value);

			if (!input) {
				this.clearResults();
				return;
			}

			try {
				const decimal = parseInt(input);
				
				if (isNaN(decimal)) {
					throw new Error('æ— æ•ˆè¾“å…¥');
				}

				// æ£€æŸ¥æ•°å€¼èŒƒå›´
				const maxValue = Math.pow(2, bits - 1) - 1;
				const minValue = -Math.pow(2, bits - 1);

				if (decimal > maxValue || decimal < minValue) {
					throw new Error(`è¶…å‡º${bits}ä½èŒƒå›´: [${minValue}, ${maxValue}]`);
				}

				// è®¡ç®—å„ç§ç¼–ç 
				const encodings = this.calculateEncodings(decimal, bits);

				// æ›´æ–°æ˜¾ç¤º
				this.signMagnitude.textContent = encodings.signMagnitude;
				this.onesComplement.textContent = encodings.onesComplement;
				this.twosComplement.textContent = encodings.twosComplement;

				// æ›´æ–°è§£é‡Š
				this.updateExplanations(decimal, bits, encodings);

				// æ¸…é™¤é”™è¯¯çŠ¶æ€
				this.clearErrorState();

			} catch (error) {
				this.showError(error.message);
			}
		}

		calculateEncodings(decimal, bits) {
			const isNegative = decimal < 0;
			const absValue = Math.abs(decimal);

			// åŸç 
			let signMagnitude = absValue.toString(2).padStart(bits - 1, '0');
			signMagnitude = (isNegative ? '1' : '0') + signMagnitude;

			// åç 
			let onesComplement;
			if (isNegative) {
				// è´Ÿæ•°çš„åç ï¼šç¬¦å·ä½ä¸º1ï¼Œå…¶ä½™ä½å–å
				onesComplement = '1' + absValue.toString(2).padStart(bits - 1, '0')
					.split('').map(bit => bit === '0' ? '1' : '0').join('');
			} else {
				// æ­£æ•°çš„åç ç­‰äºåŸç 
				onesComplement = signMagnitude;
			}

			// è¡¥ç 
			let twosComplement;
			if (isNegative) {
				// è´Ÿæ•°çš„è¡¥ç ï¼šåç åŠ 1
				let carry = 1;
				twosComplement = onesComplement.split('').reverse().map(bit => {
					if (carry === 0) return bit;
					if (bit === '0') {
						carry = 0;
						return '1';
					} else {
						return '0';
					}
				}).reverse().join('');
			} else {
				// æ­£æ•°çš„è¡¥ç ç­‰äºåŸç 
				twosComplement = signMagnitude;
			}

			return {
				signMagnitude: this.formatBinary(signMagnitude),
				onesComplement: this.formatBinary(onesComplement),
				twosComplement: this.formatBinary(twosComplement)
			};
		}

		formatBinary(binary) {
			// æ¯4ä½æ·»åŠ ä¸€ä¸ªç©ºæ ¼ï¼Œä¾¿äºé˜…è¯»
			return binary.replace(/(.{4})/g, '$1 ').trim();
		}

		updateExplanations(decimal, bits, encodings) {
			const isNegative = decimal < 0;
			const absValue = Math.abs(decimal);

			if (isNegative) {
				this.smExplanation.textContent = `è´Ÿæ•° ${decimal}ï¼šç¬¦å·ä½=1ï¼Œæ•°å€¼éƒ¨åˆ†=${absValue.toString(2)}`;
				this.ocExplanation.textContent = `è´Ÿæ•°çš„åç ï¼šç¬¦å·ä½=1ï¼Œæ•°å€¼éƒ¨åˆ†å„ä½å–å`;
				this.tcExplanation.textContent = `è´Ÿæ•°çš„è¡¥ç ï¼šåç  + 1`;
			} else {
				this.smExplanation.textContent = `æ­£æ•° ${decimal}ï¼šç¬¦å·ä½=0ï¼Œæ•°å€¼éƒ¨åˆ†=${absValue.toString(2)}`;
				this.ocExplanation.textContent = `æ­£æ•°çš„åç ç­‰äºåŸç `;
				this.tcExplanation.textContent = `æ­£æ•°çš„è¡¥ç ç­‰äºåŸç `;
			}
		}

		clearResults() {
			this.signMagnitude.textContent = '-';
			this.onesComplement.textContent = '-';
			this.twosComplement.textContent = '-';
			this.smExplanation.textContent = '';
			this.ocExplanation.textContent = '';
			this.tcExplanation.textContent = '';
			this.clearErrorState();
		}

		showError(message) {
			[this.signMagnitude, this.onesComplement, this.twosComplement]
				.forEach(el => {
					el.textContent = 'é”™è¯¯: ' + message;
					el.classList.add('error');
				});
		}

		clearErrorState() {
			[this.signMagnitude, this.onesComplement, this.twosComplement]
				.forEach(el => el.classList.remove('error'));
		}
	}

	// åˆå§‹åŒ–
	document.addEventListener('DOMContentLoaded', () => {
		new NumberBaseConverter();
		new MachineCodeEncoder();
	});
</script>
